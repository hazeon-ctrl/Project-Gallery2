<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex Territory Wars - v42</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #111827;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: #1f2937;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 850px;
        }

        h1 {
            color: white;
            font-size: 28px;
            margin-bottom: 16px;
            text-align: center;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            gap: 16px;
            flex-wrap: wrap;
        }

        .turn-info {
            color: white;
        }

        .turn-info .subtitle {
            font-size: 12px;
            opacity: 0.7;
        }

        .turn-info .current-faction {
            font-size: 18px;
            font-weight: bold;
        }

        button {
            padding: 8px 24px;
            background: #16a34a;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover:not(:disabled) {
            background: #15803d;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats {
            color: white;
            text-align: right;
            font-size: 14px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: flex-end;
        }

        .stat-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        canvas {
            border: 2px solid #4b5563;
            border-radius: 8px;
            background: #374151;
            cursor: pointer;
            display: block;
            margin: 0 auto;
        }

        .instructions {
            color: #d1d5db;
            font-size: 14px;
            margin-top: 16px;
            max-width: 700px;
        }

        .instructions strong {
            color: white;
        }

        .instructions ul {
            list-style-position: inside;
            margin-top: 8px;
        }

        .instructions li {
            margin: 4px 0;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Hex Territory Wars - v42</h1>

    <div class="controls">
        <div class="turn-info">
            <div class="subtitle" id="turnCount">Turn 1</div>
            <div class="current-faction" id="currentFaction">Blue Empire</div>
        </div>

        <button id="endTurnBtn" onclick="endTurn()">End Turn</button>

        <div class="stats">
            <div class="stat-row">
                <div class="stat-color" style="background: #3b82f6;"></div>
                <span id="blueCount">0 territories</span>
            </div>
            <div class="stat-row">
                <div class="stat-color" style="background: #ef4444;"></div>
                <span id="redCount">0 territories</span>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas" width="750" height="550"></canvas>

    <div class="instructions">
        <p><strong>How to play:</strong></p>
        <ul>
            <li><strong>Drag</strong> from your territory to an adjacent hex to attack or reinforce</li>
            <li><strong>Double-click</strong> a territory to spread armies evenly to all neighbors</li>
            <li><strong>End Turn</strong> to get bonus (territories + special terrain bonuses)</li>
            <li><strong>Mountains</strong> (gray) are impassable obstacles</li>
            <li><strong>Fortresses</strong> (gold) give +3 bonus/turn and grow at 2x speed</li>
            <li><strong>Villages</strong> (purple) give +2 bonus/turn</li>
            <li>Control special tiles for strategic advantage!</li>
        </ul>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const HEX_SIZE = 30;
    const COLS = 15;
    const ROWS = 12;

    const factions = {
        0: { color: '#e0e0e0', name: 'Neutral' },
        1: { color: '#3b82f6', name: 'Blue Empire' },
        2: { color: '#ef4444', name: 'Red Kingdom' }
    };

    const terrainTypes = {
        normal: { color: null, name: 'Normal', passable: true, bonus: 0, growthRate: 1 },
        mountain: { color: '#64748b', name: 'Mountain', passable: false, bonus: 0, growthRate: 0 },
        fortress: { color: '#fbbf24', name: 'Fortress', passable: true, bonus: 3, growthRate: 2 },
        village: { color: '#8b5cf6', name: 'Village', passable: true, bonus: 2, growthRate: 1 }
    };

    let hexes = [];
    let currentFaction = 1;
    let turnCount = 1;
    let dragStart = null;
    let dragCurrent = null;
    let lastClickTime = 0;
    let lastClickedHex = null;
    let isAiThinking = false;
    let awaitingBonus = false;
    let bonusAmount = 0;
    let audioContext = null;

    function initAudio() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        document.removeEventListener('click', initAudio);
        document.removeEventListener('mousedown', initAudio);
    }

    document.addEventListener('click', initAudio, { once: true });
    document.addEventListener('mousedown', initAudio, { once: true });

    function playSound(type) {
        if (!audioContext) return;
        if (audioContext.state === 'suspended') audioContext.resume();

        const now = audioContext.currentTime;
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);

        if (type === 'select') {
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(300, now + 0.05);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'attack') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, now);
            filter.frequency.exponentialRampToValueAtTime(300, now + 0.2);
            gain.gain.setValueAtTime(0.4, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'reinforce') {
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            gain.gain.setValueAtTime(0.25, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'turn') {
            osc.frequency.setValueAtTime(500, now);
            osc.frequency.setValueAtTime(650, now + 0.06);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
            osc.start(now);
            osc.stop(now + 0.25);
        } else if (type === 'conquest') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(500, now);
            osc.frequency.setValueAtTime(600, now + 0.1);
            osc.frequency.setValueAtTime(750, now + 0.2);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
            osc.start(now);
            osc.stop(now + 0.35);
        }
    }

    function initGame() {
        hexes = [];
        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const x = col * HEX_SIZE * 1.5;
                const y = row * HEX_SIZE * Math.sqrt(3) + (col % 2) * HEX_SIZE * Math.sqrt(3) / 2;

                let owner = 0;
                let strength = 1;
                let terrain = 'normal';

                const rand = Math.random();
                if (rand < 0.08) {
                    terrain = 'mountain';
                } else if (rand < 0.12) {
                    terrain = 'fortress';
                    strength = 5;
                } else if (rand < 0.18) {
                    terrain = 'village';
                    strength = 2;
                }

                if (col < 3 && row > ROWS - 4 && terrain !== 'mountain') {
                    owner = 1;
                    strength = terrain === 'normal' ? Math.floor(Math.random() * 3) + 3 : strength;
                }
                if (col > COLS - 4 && row < 3 && terrain !== 'mountain') {
                    owner = 2;
                    strength = terrain === 'normal' ? Math.floor(Math.random() * 3) + 3 : strength;
                }

                hexes.push({ q: col, r: row, x, y, owner, strength, terrain });
            }
        }
        updateUI();
        render();
    }

    function drawHex(x, y, size, color, highlighted, strength, terrain) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = Math.PI / 3 * i;
            const hx = x + size * Math.cos(angle);
            const hy = y + size * Math.sin(angle);
            if (i === 0) ctx.moveTo(hx, hy);
            else ctx.lineTo(hx, hy);
        }
        ctx.closePath();

        if (terrainTypes[terrain].color && color === factions[0].color) {
            ctx.fillStyle = terrainTypes[terrain].color;
        } else {
            ctx.fillStyle = color;
        }
        ctx.fill();

        if (terrain === 'mountain') {
            ctx.fillStyle = 'rgba(71, 85, 105, 0.5)';
            ctx.fill();
        } else if (terrain === 'fortress') {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 8, y + 5);
            ctx.lineTo(x - 8, y - 3);
            ctx.lineTo(x, y - 8);
            ctx.lineTo(x + 8, y - 3);
            ctx.lineTo(x + 8, y + 5);
            ctx.closePath();
            ctx.stroke();
        } else if (terrain === 'village') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(x - 4, y - 2, 8, 6);
            ctx.beginPath();
            ctx.moveTo(x - 6, y - 2);
            ctx.lineTo(x, y - 6);
            ctx.lineTo(x + 6, y - 2);
            ctx.fill();
        }

        if (highlighted) {
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 3;
        } else {
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
        }
        ctx.stroke();

        if (strength > 0 && terrain !== 'mountain') {
            const displayStrength = Math.min(strength, 999);
            ctx.fillStyle = terrain === 'fortress' || terrain === 'village' ? '#fff' : '#000';
            ctx.font = strength > 99 ? 'bold 11px sans-serif' : 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(displayStrength, x, y + 8);
        }
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        hexes.forEach(hex => {
            const highlighted = (dragStart && hex === dragStart) ||
                (awaitingBonus && hex.owner === currentFaction && hex.terrain !== 'mountain');
            drawHex(hex.x + 40, hex.y + 40, HEX_SIZE,
                factions[hex.owner].color, highlighted, hex.strength, hex.terrain);
        });

        if (dragStart && dragCurrent) {
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 4;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(dragStart.x + 40, dragStart.y + 40);
            ctx.lineTo(dragCurrent.x, dragCurrent.y);
            ctx.stroke();
            ctx.setLineDash([]);

            const angle = Math.atan2(dragCurrent.y - (dragStart.y + 40),
                dragCurrent.x - (dragStart.x + 40));
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.moveTo(dragCurrent.x, dragCurrent.y);
            ctx.lineTo(dragCurrent.x - 15 * Math.cos(angle - Math.PI / 6),
                dragCurrent.y - 15 * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(dragCurrent.x - 15 * Math.cos(angle + Math.PI / 6),
                dragCurrent.y - 15 * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        if (awaitingBonus && currentFaction === 1) {
            ctx.fillStyle = 'rgba(251, 191, 36, 0.9)';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const text = `Click a territory to add +${bonusAmount} bonus!`;
            const textWidth = ctx.measureText(text).width;
            ctx.fillRect(375 - textWidth / 2 - 10, 20, textWidth + 20, 40);
            ctx.strokeRect(375 - textWidth / 2 - 10, 20, textWidth + 20, 40);
            ctx.fillStyle = '#000';
            ctx.fillText(text, 375, 40);
        }
    }

    function getHexAtPoint(x, y) {
        return hexes.find(hex => {
            const dx = x - (hex.x + 40);
            const dy = y - (hex.y + 40);
            return Math.sqrt(dx * dx + dy * dy) < HEX_SIZE;
        });
    }

    function getNeighbors(hex) {
        const neighbors = [];
        const offsets = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, -1], [-1, 1]];

        offsets.forEach(([dq, dr]) => {
            const neighbor = hexes.find(h => h.q === hex.q + dq && h.r === hex.r + dr);
            if (neighbor) neighbors.push(neighbor);
        });

        return neighbors;
    }

    function updateUI() {
        document.getElementById('turnCount').textContent = `Turn ${turnCount}`;
        document.getElementById('currentFaction').textContent = factions[currentFaction].name;
        document.getElementById('currentFaction').style.color = factions[currentFaction].color;

        const blueCount = hexes.filter(h => h.owner === 1 && h.terrain !== 'mountain').length;
        const redCount = hexes.filter(h => h.owner === 2 && h.terrain !== 'mountain').length;
        document.getElementById('blueCount').textContent = `${blueCount} territories`;
        document.getElementById('redCount').textContent = `${redCount} territories`;

        const btn = document.getElementById('endTurnBtn');
        btn.disabled = currentFaction !== 1 || isAiThinking || awaitingBonus;
        btn.textContent = awaitingBonus ? 'Place Bonus...' : 'End Turn';
    }

    function handlePropagate(sourceHex) {
        if (!sourceHex || sourceHex.owner !== currentFaction || sourceHex.strength <= 1 || sourceHex.terrain === 'mountain') return;

        const neighbors = getNeighbors(sourceHex).filter(n => n.terrain !== 'mountain');
        if (neighbors.length === 0) return;

        const totalToDistribute = sourceHex.strength - 1;
        const perNeighbor = Math.floor(totalToDistribute / neighbors.length);

        if (perNeighbor === 0) return;

        playSound('reinforce');

        hexes = hexes.map(h => {
            if (h === sourceHex) {
                return { ...h, strength: 1 };
            }
            if (neighbors.includes(h)) {
                if (h.owner === currentFaction) {
                    return { ...h, strength: h.strength + perNeighbor };
                } else {
                    const attackStrength = perNeighbor;
                    const defenseStrength = h.strength;

                    if (attackStrength > defenseStrength) {
                        setTimeout(() => playSound('conquest'), 100);
                        return { ...h, owner: currentFaction, strength: attackStrength - defenseStrength };
                    } else if (attackStrength === defenseStrength) {
                        return { ...h, owner: 0, strength: 1 };
                    } else {
                        return { ...h, strength: defenseStrength - attackStrength };
                    }
                }
            }
            return h;
        });

        updateUI();
        render();
        setTimeout(() => endTurn(), 100);
    }

    function endTurn() {
        if (currentFaction === 1) {
            const playerTerritories = hexes.filter(h => h.owner === 1 && h.terrain !== 'mountain');
            const territoryCount = playerTerritories.length;
            const terrainBonus = playerTerritories.reduce((sum, hex) =>
                sum + terrainTypes[hex.terrain].bonus, 0);

            if (territoryCount > 0 && !awaitingBonus) {
                bonusAmount = territoryCount + terrainBonus;
                awaitingBonus = true;
                playSound('turn');
                updateUI();
                render();
                return;
            }
        }

        completeTurn();
    }

    function completeTurn() {
        playSound('turn');

        hexes = hexes.map(hex => {
            if (hex.owner !== 0 && hex.strength < 20 && hex.terrain !== 'mountain') {
                const growthRate = terrainTypes[hex.terrain].growthRate;
                return { ...hex, strength: Math.min(hex.strength + growthRate, 20) };
            }
            return hex;
        });

        currentFaction = currentFaction === 1 ? 2 : 1;
        if (currentFaction === 1) turnCount++;

        awaitingBonus = false;
        bonusAmount = 0;
        dragStart = null;
        dragCurrent = null;

        updateUI();
        render();

        if (currentFaction === 2) {
            setTimeout(aiTurn, 1000);
        }
    }

    function aiTurn() {
        isAiThinking = true;
        updateUI();

        const aiHexes = hexes.filter(h => h.owner === 2 && h.strength > 1 && h.terrain !== 'mountain');
        if (aiHexes.length === 0) {
            aiBonus();
            return;
        }

        const attackCount = Math.min(Math.floor(aiHexes.length / 3) + 1, 5);
        let updatedHexes = [...hexes];

        for (let attack = 0; attack < attackCount; attack++) {
            const validAttackers = updatedHexes.filter(h => h.owner === 2 && h.strength > 2 && h.terrain !== 'mountain');
            if (validAttackers.length === 0) break;

            const sortedHexes = [...validAttackers].sort((a, b) => {
                const aValue = b.strength + (b.terrain === 'fortress' ? 10 : b.terrain === 'village' ? 5 : 0);
                const bValue = a.strength + (a.terrain === 'fortress' ? 10 : a.terrain === 'village' ? 5 : 0);
                return aValue - bValue;
            });

            let attackMade = false;

            for (const attackingHex of sortedHexes) {
                const neighbors = getNeighbors(attackingHex);
                const targets = neighbors.filter(n => n.owner !== 2 && n.terrain !== 'mountain');

                if (targets.length > 0) {
                    const target = targets.sort((a, b) => {
                        const aValue = (a.terrain === 'fortress' ? 100 : a.terrain === 'village' ? 50 : 0) - a.strength;
                        const bValue = (b.terrain === 'fortress' ? 100 : b.terrain === 'village' ? 50 : 0) - b.strength;
                        return bValue - aValue;
                    })[0];

                    if (attack === 0) playSound('attack');

                    updatedHexes = updatedHexes.map(h => {
                        if (h.q === target.q && h.r === target.r) {
                            const attackStrength = attackingHex.strength - 1;
                            const defenseStrength = target.strength;

                            if (attackStrength > defenseStrength) {
                                if (attack === 0) setTimeout(() => playSound('conquest'), 100);
                                return { ...h, owner: 2, strength: attackStrength - defenseStrength };
                            } else {
                                return { ...h, strength: defenseStrength - attackStrength };
                            }
                        }
                        if (h.q === attackingHex.q && h.r === attackingHex.r) {
                            return { ...h, strength: 1 };
                        }
                        return h;
                    });

                    attackMade = true;
                    break;
                }
            }

            if (!attackMade) break;
        }

        hexes = updatedHexes;
        render();
        setTimeout(aiBonus, 500);
    }

    function aiBonus() {
        const aiTerritories = hexes.filter(h => h.owner === 2 && h.terrain !== 'mountain');
        const territoryCount = aiTerritories.length;
        const terrainBonus = aiTerritories.reduce((sum, hex) =>
            sum + terrainTypes[hex.terrain].bonus, 0);
        const bonus = territoryCount + terrainBonus;

        if (bonus > 0 && aiTerritories.length > 0) {
            const strongest = aiTerritories.sort((a, b) => {
                const aValue = b.strength + (b.terrain === 'fortress' ? 20 : b.terrain === 'village' ? 10 : 0);
                const bValue = a.strength + (a.terrain === 'fortress' ? 20 : a.terrain === 'village' ? 10 : 0);
                return aValue - bValue;
            })[0];

            hexes = hexes.map(h => {
                if (h.q === strongest.q && h.r === strongest.r) {
                    return { ...h, strength: h.strength + bonus };
                }
                return h;
            });
            render();
        }

        setTimeout(() => {
            isAiThinking = false;
            completeTurn();
        }, 300);
    }

    canvas.addEventListener('mousedown', (e) => {
        if (currentFaction !== 1 || isAiThinking) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const clickedHex = getHexAtPoint(x, y);

        if (awaitingBonus && clickedHex && clickedHex.owner === currentFaction && clickedHex.terrain !== 'mountain') {
            playSound('conquest');
            hexes = hexes.map(h => {
                if (h === clickedHex) {
                    return { ...h, strength: h.strength + bonusAmount };
                }
                return h;
            });
            completeTurn();
            return;
        }

        if (awaitingBonus) return;

        const now = Date.now();
        if (clickedHex && lastClickedHex === clickedHex && now - lastClickTime < 400) {
            handlePropagate(clickedHex);
            lastClickTime = 0;
            lastClickedHex = null;
            return;
        }

        lastClickTime = now;
        lastClickedHex = clickedHex;

        if (clickedHex && clickedHex.owner === currentFaction && clickedHex.strength > 1 && clickedHex.terrain !== 'mountain') {
            dragStart = clickedHex;
            dragCurrent = { x, y };
            playSound('select');
            render();
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (dragStart) {
            const rect = canvas.getBoundingClientRect();
            dragCurrent = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            render();
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        if (!dragStart) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const targetHex = getHexAtPoint(x, y);

        if (targetHex && targetHex !== dragStart && targetHex.terrain !== 'mountain') {
            const neighbors = getNeighbors(dragStart);

            if (neighbors.includes(targetHex)) {
                if (targetHex.owner !== currentFaction) {
                    playSound('attack');
                    hexes = hexes.map(h => {
                        if (h === targetHex) {
                            const attackStrength = dragStart.strength - 1;
                            const defenseStrength = targetHex.strength;

                            if (attackStrength > defenseStrength) {
                                playSound('conquest');
                                return { ...h, owner: currentFaction, strength: attackStrength - defenseStrength };
                            } else {
                                return { ...h, strength: defenseStrength - attackStrength };
                            }
                        }
                        if (h === dragStart) {
                            return { ...h, strength: 1 };
                        }
                        return h;
                    });
                } else {
                    playSound('reinforce');
                    hexes = hexes.map(h => {
                        if (h === targetHex) {
                            return { ...h, strength: h.strength + dragStart.strength - 1 };
                        }
                        if (h === dragStart) {
                            return { ...h, strength: 1 };
                        }
                        return h;
                    });
                }

                updateUI();
                render();
                setTimeout(() => endTurn(), 100);
            }
        }

        dragStart = null;
        dragCurrent = null;
        render();
    });

    initGame();
</script>
</body>
</html>